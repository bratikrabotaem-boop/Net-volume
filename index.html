<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<title>BTC-USDT · Net Volume (Realtime)</title>

<script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>

<style>
body {
  margin:0;
  background:#121417;
  color:#e6e6e6;
  font-family:Arial,sans-serif;
}
.wrapper {
  max-width:1100px;
  margin:20px auto;
  padding:0 10px;
}
.title { text-align:center; font-size:18px; }
.sub { text-align:center; font-size:13px; color:#8a8a8a; margin-bottom:8px; }

.tf-buttons {
  display:flex;
  justify-content:center;
  gap:8px;
  margin-bottom:8px;
  flex-wrap:wrap; /* Для мобильных */
}
.tf-buttons button {
  background:#2a2d33;
  border:0;
  color:#ccc;
  padding:5px 10px;
  border-radius:4px;
  font-size:12px;
  cursor:pointer;
  transition:background 0.2s;
}
.tf-buttons button:hover {
  background:#3f434b;
}
.tf-buttons button.active {
  background:#3f434b;
  color:#fff;
}

.loading {
  text-align:center;
  color:#8a8a8a;
  font-size:14px;
  margin:20px 0;
}

#price, #volume {
  touch-action:none !important;
  width:100%;
}
/* Responsive heights */
#price { height:420px; }
#volume { height:140px; }
@media (max-width: 768px) {
  #price { height:300px; }
  #volume { height:100px; }
  .tf-buttons { gap:4px; }
  .tf-buttons button { padding:4px 8px; font-size:11px; }
}
</style>
</head>

<body>
<div class="wrapper">
  <div class="title">BTC-USDT · NET VOLUME</div>
  <div class="sub">BINANCE · REALTIME</div>

  <div class="tf-buttons">
    <button onclick="setTF('1d', this)">1D</button>
    <button onclick="setTF('4h', this)">4H</button>
    <button onclick="setTF('1h', this)" class="active">1H</button>
    <button onclick="setTF('30m', this)">30M</button>
    <button onclick="setTF('15m', this)">15M</button>
    <button onclick="setTF('5m', this)">5M</button>
  </div>

  <div id="loading" class="loading" style="display:none;">Загрузка данных...</div>
  <div id="price"></div>
  <div id="volume"></div>
</div>

<script>
/* ===== iOS ZOOM BLOCK ===== */
['gesturestart','gesturechange','gestureend'].forEach(e=>{
  document.addEventListener(e,ev=>ev.preventDefault(),{passive:false});
});

/* ===== TIME FORMAT (БЕЗ СЕКУНД, БЕЗ СМЕЩЕНИЙ) ===== */
function formatTimeNoSeconds(time) {
  const d = new Date(time * 1000);
  const date = d.toLocaleDateString('ru-RU', {
    day: '2-digit',
    month: 'short',
    year: '2-digit'
  });
  const hh = String(d.getHours()).padStart(2, '0');
  const mm = String(d.getMinutes()).padStart(2, '0');
  return `${date} ${hh}:${mm}`;
}

/* ===== APP STATE ===== */
let INTERVAL = '1h';
let ws = null;
let sessionId = 0;
let debounceTimer = null;

/* ===== REALTIME VOLUME STATE ===== */
let currentBarTime = null;
let lastV = 0;
let lastQ = 0;
let currentNet = 0;
let baseNet = 0;

/* ===== ELEMENTS ===== */
const priceEl = document.getElementById('price');
const volumeEl = document.getElementById('volume');
const loadingEl = document.getElementById('loading');

/* ===== COMMON OPTIONS ===== */
const commonOpts = {
  layout: { background: { color: '#121417' }, textColor: '#ccc' },
  grid: { vertLines: { color: '#1e2228' }, horzLines: { color: '#1e2228' } },
  localization: {
    timeFormatter: formatTimeNoSeconds
  },
  timeScale: {
    timeVisible: true,
    secondsVisible: false,
    timeFormatter: formatTimeNoSeconds,
    rightBarStaysOnScroll: true,
    lockVisibleTimeRangeOnResize: true
  },
  handleScroll: {
    mouseWheel: false,
    pressedMouseMove: true,
    horzTouchDrag: true,
    vertTouchDrag: false
  }
};

/* ===== PRICE CHART ===== */
const priceChart = LightweightCharts.createChart(priceEl, {
  ...commonOpts,
  handleScale: { mouseWheel: false, axisPressedMouseMove: false, pinch: true },
  rightPriceScale: { visible: false },
  leftPriceScale: { visible: false }
});

const candles = priceChart.addCandlestickSeries({
  upColor: '#1fc77b',
  downColor: '#e04b4b',
  borderUpColor: '#1fc77b',
  borderDownColor: '#e04b4b',
  wickUpColor: '#1fc77b',
  wickDownColor: '#e04b4b'
});

/* ===== VOLUME CHART ===== */
const volumeChart = LightweightCharts.createChart(volumeEl, {
  ...commonOpts,
  handleScale: { mouseWheel: false, axisPressedMouseMove: false, pinch: false },
  rightPriceScale: { visible: false },
  leftPriceScale: { visible: false }
});

const volumeSeries = volumeChart.addHistogramSeries({
  base: 0,
  priceFormat: { type: 'volume' }
});

/* ===== SYNC CHARTS ===== */
let syncing = false;
function syncCharts(a, b) {
  a.timeScale().subscribeVisibleLogicalRangeChange(range => {
    if (syncing || !range) return;
    syncing = true;
    b.timeScale().setVisibleLogicalRange(range);
    syncing = false;
  });
}
syncCharts(priceChart, volumeChart);
syncCharts(volumeChart, priceChart);

/* ===== RESIZE ===== */
function resizeCharts() {
  priceChart.resize(priceEl.clientWidth, priceEl.clientHeight);
  volumeChart.resize(volumeEl.clientWidth, volumeEl.clientHeight);
}
window.addEventListener('resize', resizeCharts);
resizeCharts(); // Initial resize

/* ===== DEBOUNCE FOR API CALLS ===== */
function debounceLoadData() {
  if (debounceTimer) clearTimeout(debounceTimer);
  debounceTimer = setTimeout(loadData, 500);
}

/* ===== LOAD HISTORY ===== */
async function loadData() {
  sessionId++;
  const currentSession = sessionId;
  loadingEl.style.display = 'block';

  // Reset state
  currentBarTime = null;
  currentNet = 0;
  baseNet = 0;
  lastV = 0;
  lastQ = 0;

  // Close existing WS
  if (ws) {
    ws.onmessage = null;
    ws.close();
    ws = null;
  }

  try {
    const response = await fetch(
      `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=${INTERVAL}&limit=500`
    );
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const data = await response.json();

    const candlesData = [];
    const volumeData = [];
    data.forEach(k => {
      const time = k[0] / 1000; // UTC seconds

      candlesData.push({
        time: time,
        open: +k[1],
        high: +k[2],
        low: +k[3],
        close: +k[4]
      });

      const net = 2 * k[10] - k[7]; // 2*quote - base
      volumeData.push({
        time: time,
        value: net / 1e6,
        color: net >= 0 ? '#1fc77b' : '#e04b4b'
      });
    });

    // Set baseNet from the last complete bar (before current)
    const lastCompleteBar = data[data.length - 2] || data[data.length - 1];
    if (lastCompleteBar) {
      baseNet = (2 * +lastCompleteBar[10] - +lastCompleteBar[7]) / 1e6;
    }

    candles.setData(candlesData);
    volumeSeries.setData(volumeData);

    priceChart.timeScale().fitContent();
    resizeCharts();

    // Start realtime only if this is the current session
    if (currentSession === sessionId) {
      startRealtime(currentSession);
    }
  } catch (error) {
    console.error('Error loading data:', error);
    alert('Ошибка загрузки данных. Проверьте соединение и попробуйте снова.');
  } finally {
    if (currentSession === sessionId) {
      loadingEl.style.display = 'none';
    }
  }
}

/* ===== REALTIME ===== */
function startRealtime(currentSession) {
  if (currentSession !== sessionId) return;

  ws = new WebSocket(
    `wss://stream.binance.com:9443/ws/btcusdt@kline_${INTERVAL}`
  );

  ws.onopen = () => {
    console.log('WS connected');
  };

  ws.onmessage = (e) => {
    if (currentSession !== sessionId) return;

    try {
      const kline = JSON.parse(e.data).k;
      const time = Math.floor(kline.t / 1000);

      // Update candle
      candles.update({
        time: time,
        open: +kline.o,
        high: +kline.h,
        low: +kline.l,
        close: +kline.c
      });

      // Handle volume net
      if (currentBarTime !== time) {
        currentBarTime = time;
        lastV = +kline.V;
        lastQ = +kline.Q;
        currentNet = baseNet * 1e6; // Start from base (in raw units)
      }

      const dV = +kline.V - lastV;
      const dQ = +kline.Q - lastQ;
      lastV = +kline.V;
      lastQ = +kline.Q;

      currentNet += (2 * dQ - dV); // Increment net

      // Update volume bar
      volumeSeries.update({
        time: time,
        value: currentNet / 1e6,
        color: currentNet >= 0 ? '#1fc77b' : '#e04b4b'
      });
    } catch (err) {
      console.error('WS message error:', err);
    }
  };

  ws.onerror = (err) => {
    console.error('WS error:', err);
  };

  ws.onclose = () => {
    console.log('WS closed, reconnecting...');
    if (currentSession === sessionId) {
      setTimeout(() => startRealtime(currentSession), 2000);
    }
  };
}

/* ===== TIMEFRAME CHANGE ===== */
function setTF(tf, buttonEl) {
  if (INTERVAL === tf) return; // Already active

  INTERVAL = tf;

  // Update active button
  document.querySelectorAll('.tf-buttons button').forEach(b => b.classList.remove('active'));
  buttonEl.classList.add('active');

  // Debounced load
  debounceLoadData();
}

// Initial load
loadData();
</script>
</body>
</html>
